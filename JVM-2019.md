### JVM

### JVM内存区域

<img src="/Users/swq/Library/Application Support/typora-user-images/image-20210511213827818.png" alt="image-20210511213827818" style="zoom:50%;" />

#### 栈内存空间

- 由一个个栈帧组成,每个栈帧中拥有:操作数栈,局部变量表,动态链接,方法返回值信息
- 局部变量表:存储基础数据类型,对象的引用
- 操作数栈:操作数据运算的地方,用于临时计算数据的数据存储区

#### 堆内存

<img src="/Users/swq/Library/Application Support/typora-user-images/image-20210511214145014.png" alt="image-20210511214145014" style="zoom:50%;" />

-  

#### Java运行时数据区(内存分配)

- **程序计数器**:用来存储下一条程序指令(字节码行号),类似于指针,线程私有,存储循环,判断,异常处理,线程恢复等等指令地址,随着线程创建而创建,线程死亡而死亡,
- **Java栈**,线程私有,每一个线程都会有一个Java栈,存储局部变量,,基本数据类型的变量,直接存储它的值,引用类型变量,存储对象的引用,保存常量的引用,以及实例方法,它的生命周期和程序计数器一样,不存在垃圾回收机制;
- **本地方法栈**,用来执行java方法的服务所存在,线程私有,**主要用来执行native方法**
- **Java堆**,线程共享,,存放对象实例,存储对象和数组本身,JVM中只有一个堆
- **方法区**(元空间),线程共享,JVM只有一个方法区,用来存储每个类的信息(类名,方法信息,字段信息)**,静态变量,常量**,和编译器编译过的代码,还有常量区,**存储每个类的结构信息**,是一种规范;

> 对象的引用放在栈,实例放在堆中,对象信息,规范或者是标准,放在方法区

### Java内存模型特性:

- **内存可见性**:一个线程对共享变量的修改,可以被其他线程知道并同步,保持该数据的同步,操作原理为主内存数据交互同步;
- **原子性**:原子性指的是多线程中,操作数据要保证数据的一致性,要么全部成功,要么全部失败,可被分割,不可被干扰,不可被中断;JUC包的原子类可以保证原子性;
- **有序性**:Java执行的指令按照顺序执行,不进行指令重排;
- **指令重排**:指的是多线程环境下,编译器在保证数据的依赖性情况下,会对Java指令的顺序修改 可能会导致乱序执行,最终导致结果可能会和预期不一致;

#### 内存屏障:

- CPU指令中,有一个内存屏障(Memory Barrier) ,读屏障和写屏障,它有2个作用
- **保证内存可见性**:保证所有线程获取到最新插入读屏障,强制刷新CPU的1 2 3级缓存数据,的数据,实现了内存可见性,保证数据是最新的,
- **禁止指令重排**:因为编译器和CPU都能执行指令重排优化,如果在指令中插入了内存屏障,它就会在CPU和编译器中禁止指令去进行重排序

### 类加载机制

- 把指定class文件根据加载到内存中,进行解析和初始化,然后解析为JVM可以使用的的类型

#### 类加载器是什么 ClassLoader

- 获取一个class文件的的全限定名,把其中的二进制字节码加载到运行时数据区的方法区中做类加载器

#### 类加载器有哪些

> 4种

- 启动类加载器,bootstrap加载器,用来加载rtjar包的核心类库;
- ExtClassLoader ext加载器,也叫扩展类加载器,用来加载Java核心包之外的拓展类
- AppClassLoader,系统类加载器,也叫应用类加载器,用来加载Java应用下的class类
- 自定义加载器,用户可以通过集成java.lang.ClassLoader类来进行实现

#### 双亲委派模型:

- 当一个类加载器接收到了类加载的请求的时候,会首先把这个请求交给它的父类,每一个类加载器都是这样,如果这个类加载器无法完成加载,也就是没有找到对应的类,它会把这个类加载器交给它的子类去进行加载,这样做的好处是为了**不污染Java底层的源代码**;



### GC

#### 垃圾回收机制:

**minorgc**:

- 回收年轻代垃圾(包含eden和S0和S1)

#### 垃圾回收算法

#### 垃圾收集器

