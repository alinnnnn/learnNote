#### volatile(轻量级的同步机制):

三个特性:

- 内存可见性
- 禁止指令重排
- 不保证原子性

> 实现原理:参考JVM笔记第二条的内存屏障

#### 多线程下的单例模式

- 懒加载+双重检索机制(DCL double check lock)+禁止指令重排(volatile)
- **禁止指令重排**:一个线程调用该方法,该对象分配完内存空间的时候,但是还没有把引用指向内存地址,没有初始化完成的时候,另一个线程访问对象,判断不为null,会返回空对象;
- **双端检索**:同步代码块前后加入对象获取的判断,多线程环境下,既能保证效率,也能保证只会创建一个对象,
- volatile使用了内存屏障 代码如下:

```
private SingtoleDemo(){};
private  static   volatile      SingtoleDemo singtoleDemo = null;
public static  SingtoleDemo getInstance(){
    if (singtoleDemo == null) {
        synchronized (SingtoleDemo.class) {
            if (getInstance() == null) {
                singtoleDemo = new SingtoleDemo();
            }
        }
    }
    return singtoleDemo;
}
```

#### CAS(比较并交换)

- 是一种实现并发算法常用的技术:一种无锁算法,在线程中,在不用锁的情况下,要修改一个共享数据,如果线程中获取的数据和主内存实际数据相同,就进行修改,如果获取的数据和和主内存实际数据不相同,则不进行修改（乐观锁的实现）
- CAS的操作是原子性的,是一条CPU并发原语(原语操作是基于硬件,一种操作系统用语,由N个指令组成,它的特点是执行必须是连续的,不允许被中断),所以基于cpu的这种指令,它的操作不会导致数据不一致问题)

#### JUC包的AtomicInteger:

- 使用了CAS+volatile保证多线程环境下数据的原子性和内存可见性以及禁止指令重排;
- **实现原理**:原子类实现了多线程环境下,数据操作的原子性,它操作的执行依赖于底层的sun.misc包的UnSaFe类,UnSafe类里面有大量的native方法,它依赖于底层的CAS去实现原子操作;
- 调用unsafe的方法后,它会去拿要修改的数据和内存中的数据进行比较,如果相同,则进行原子操作,否则就会循环去获取最新数据,直到要修改的数据和内存中的数据相同,最终进行原子操作,返回正确数据
- 原子类使用了volatile修饰,保证了内存可见性,所以实现了这样一个数据的一致性,不会发现多线程环境下的并发问题

#### CAS缺点:

- 如果CAS失败,会进行自旋,加大CPU开销
- 只能对一个共享变量进行CAS,否则只能有synchronized保证原子性

#### ABA问题:

- 取出内存数据到进行CAS操作,有一个时间差,这个时间差里面可能会导致数据的变化,这里面需要考虑的是不仅是数据一致性问题,还要考虑数据的版本问题
- 使用AtomicStampedReference类的compareAndSet修改版本号,类似于时间戳,传入4个参数,第一个是预期值,第二个是要修改的值,第三个是当前版本号,第四个是修改成功后会修改版本号,版本号修改的值,版本号不一致,则修改失败

#### 为什么不使用synchronized,而是使用CAS

- synchronized,同一个时间段,只允许一个线程访问,一致性得到了保障,但是并发性下降,效率低下,
- CAS保证原子性,保证了效率区别于synchronized这种重量级锁

#### 公平锁/非公平锁

- **公平锁**:多线程按照申请锁的顺序来获取锁,先进先出原则
- **非公平锁**:多线程并不是按照申请锁的顺序来获取锁,可能后面申请的线程比优先申请的线程先获得锁
- Java中的ReentrantLock 默认是非公平锁,非公平锁的优点是吞吐量比公平锁大，synchronized是一种非公平锁
- 公平锁和非公平锁的区别的是公平锁需要判断等待队列是否没有有效节点

#### 可重入锁(递归锁)

- ReentrantLock/synchronized都是可重入锁
- **定义**：应用层:同一个线程在外层方法获取锁是,再去获取内部锁时会自动获取锁,不会因为之前的外部锁没释放而阻塞
- synchronized可重入锁原理:Jvm使用synchronized内部的监听器锁monitorenter和monitorexit字节指令控制线程锁,线程执行monitorenter时,锁的计数器+1,其他线程获取锁时,会被拒绝,执行monitorexit指令是,锁的计数器-1,如果计数器为0是,表示这个锁被释放了,可以被其他线程持有

#### 自旋锁

- 获取锁的时候不会进行阻塞,而是循环的尝试去获取锁,直到获取锁为止,这样能减少上下文的切换,缺点是加大CPU开销

#### 独占锁(写锁)/共享锁(读锁)

- 独占锁:该锁一次只能被一个线程所持有
- ReentrantLock/synchronized都是独占锁
- 共享锁:该锁可以被多个线程所持有

#### ReentrantReadWriteLock(可重入的读写锁)

- 写操作:原子性+独占锁,整个过程必须是完整的,不可被打断
- 读锁是一种共享锁,它能够被多个线程同时访问,并且保证并发性,
- 读写分离,提升效率

#### 互斥锁

- 同一时间只允许一个线程访问该数据,对数据的独占使用,执行顺序是乱序

#### synchronized和lock的区别

- synchronized是JVM级别，lock是JUC包下的锁机制,属于代码层次
- synchronized不可被中断,除非抛出异常或者正常运行完成，lock可以被中断设置超时方法,.trylock(long time.Time Unitunit)
- synchronized会自动释放锁，ReentrantLock需要手动释放锁,在finally释放锁,以防死锁
- synchronized是非公平锁，ReentrantLock 都可以,构造方法中默认为false,非公平锁,true为公平锁

#### 线程池

> 为什么要用线程池, 1.资源复用,降低资源消耗,通过重复利用以及存在的线程降低线程创建和销毁带来的消耗 2.提高线程的可管理性,线程是稀缺资源,如果无限的创建,就会消耗系统资源,降低系统稳定性,这样以来可以使用线程池来管理线程,做统一分配,调度 3.提高响应速度,创建线程池后,任务以来,就不需要创建新线程,直接的放到线程池里面使用

#### 线程池参数:

- **corePoolSize**:线程池中的常驻核心线程数,也叫初始化时候创建的线程数量,创建线程池后,有需要执行的任务时,会去安排线程池中的线程执行任务,当线程池中线程数目达到corepoolsize后,就会把剩余的任务放入缓存队列
- **maximumPoolSize**:线程池能够容纳同时执行的最大线程数量,必须大于1
- **keepAliveTime**,超过corePoolSize的空闲线程的存活时间,如果当前线程池中的线程数量超过了corePoolsize,超出corepoolsize的线程它的空闲时间达到了keepAlivetime,则会进行销毁,直到只剩下corePoolSize的线程数量
- **unit**:KeepAliveTime的时间单位 TIMEUInit.senonds
- **workqueue**: 任务队列,用于放入被提交但是没有被执行的任务
- **threadFectory** :线程工厂,用于创建线程
- **拒绝策略**,缓存队列满了,并且工作线程大于等于线程池能够容纳同时执行的最大线程数量

> - AbortPolicy(默认拒绝策略)直接跑出RejectExcutionException 异常,阻止系统正常运行
> - CallerRunsPolicy:任务退回处理,谁提交的线程任务,就会被退回给谁,
> - DiscardOldestPolicy,先阻塞队列头部的线程任务,相当于扔掉,然后放入阻塞队列,最后尝试去执行
> - DiscardPolicy:不处理,直接丢弃,相当于不做任何操作

![图解线程池实现原理](https://camo.githubusercontent.com/cf627f637b4c678cd77b815fbea8789dd3158b0c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f2545352539422542452545382541372541332545372542412542462545372541382538422545362542312541302545352541452539452545372538452542302545352538452539462545372539302538362e706e67)

#### 死锁定位/死锁

- 死锁是2个或2个以上进程在执行过程中,由于彼此互相等待对方释放资源而造成的阻塞的一种情况,
- jps -l 定位进程号 jstack 进程号,查看问题

#### wait和notify方法

- 只支持synchronized的使用
- 必须先wait再notify,否则无法被唤醒

#### LockSupport

- 支持唤醒和阻塞线程,使用park等待和unpark唤醒方法
- 支持先unpark唤醒指定线程,后park线程
- Locksupport使用了许可证,类似于信号量,只有0和1,每个线程都有一个许可,上限为1,线程阻塞需要消耗凭证,调用park方法,如果没有凭证,会阻塞,等待有凭证,等待有凭证时消耗这个凭证,然后阻塞退出,使用unpark可以增加1个凭证;

#### Condition的await和signal方法

- 只支持synchronized或者Lock的使用
- 必须先await再signal,否则无法被唤醒

#### AQS原理

- AQS使用volatile修饰的int型变量来表示同步状态,通过内置的FIFO队列,把每个需要抢占资源的线程分配给Node节点来实现锁的分配,再通过CAS来完成对state的状态进行修改同步











