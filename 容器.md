#### 解决线程不安全的ArrayList

- java.util.Collections.**synchronizedlist**(),传入Arraylist对象,实现线程安全(依赖synchronized)
- JUC包的**CopyonWriteArrayList**(依赖**volatile**+非公平锁**ReentrantLock**),读写分离；

> **原理**：操作数据时,先锁住,创建一个新数组,在新数组进行操作,操作完成,然后再指向原来数组,读操作是,在原来数组获取,读写分离,互不影响 **缺点**:**内存占用**,写操作需要创建新数组,使用内存为原来的两倍，读操作无法获取实时性数据,因为写操作的数据可能没有放入原数组中,造成**数据不一致**

#### HashCode和equals

- 一个对象的的hashcode应该是唯一的,表示一个对象的唯一地址,不会改变的, 如果2个对象调用equals方法返回true,那么它们的hashcode必须是一样的,
- 如果重写equals，必须也重写hashcode方法，因为默认hashcode方法是在堆对象根据算法产生独特的值，如果不重写，这个class的2个对象无论怎样都不会相等

#### HashMap（1.8）:

- **数据结构**：HashMap使用的数据结构是数组+链表+红黑树(一种平衡二叉树)实现的,实现了数组的线性查找优势和链表的寻址修改优势的结合,不保证有序，
- **线程安全**：HashMap并不是synchronized,,所以是线程不安全的,效率会很快,HashMap可以允许key为null,Hashtable则不能,Hashmap是后面出的,经过API处理了；
- **成员变量**:默认数组长度:16个默认负载因子:0.75HashMap的最大容量(Capacity)是1的30次方(允许存放元素的个数)；
- **put原理**:通过调用hashmap的hash函数,这个函数通过获取key的hashcode,然后再进行一个异或运算计算返回一个hash值,然后通过(数组长度-1)&hash值计算它的下标,如果hash值没有重复,则直接放入数组中,如果hash值重复,以链表的形式放在数组后面,, 如果链表长度超过或者等于8(或者数组长度超过64),就会把当前链表转成红黑树(O(logn)),如果链表小于6,就会把红黑树转为链表,
- **扩容机制**:如果当前keyvalue的个数超过了数组长度的0.75倍(默认负载因子),就会调用resize方法进行扩容,扩容为原数组的2倍,先如扩容，然后重新hash
- **hash碰撞**：hash算法获得的hash值可能相同，导致链表过长，影响性能
- **减少hash碰撞**: 双重hash
- **1.7多线程操作死循环问题**：多线程环境扩容时，链表节点顺序被修改了，节点可能会造成互相指向的情况(俗称链表环问题)，造成死循环
- **1.7和1.8的区别**：

> 1.7使用的是Entry数组存储,用key的hashcode取模决定key的下标,如果hashcode的情况很差,它们这些数据会存储到一个链表中,导致这个链表会一直很长,所以的get操作和put操作会遍历很久,1.7使用的是链表头插法,插入元素会放到链表的头部,并发情况（1.7头插法的问题）可能会造成逆序环形链表死循环,1.7获取hash值方法不一样,使用了4次位运算和5次异或,

> 1.8使用的是Node数组存储,这个node可能是红黑树结构,也可能是链表结构,1.8使用红黑树后,改成了尾插法,不会打乱链表元素本来的顺序,可以避免不会出现链表环的死循环问题,1.8使用的是1次位运算和1次异或处理

- **为什么HashMap中,链表长度大于等于8会转为红黑树**

  > 为了避免频繁的转换,根据泊松分布，在负载因子0.75（HashMap默认）的情况下，单个hash槽内元素个数为8的概率小于百万分之一,7作为分水岭,小于等于6时转为链表

#### ConcurrentHashMap

- **定义**：不允许key为null,是JUC包下面的一种HashMap的线程安全的实现,
- **1.8版本之前**:使用的是一种**分段锁**机制用在并发编程上,使用了可重入锁Reentrantlock,实现了线程安全,但是它比synchronized效率快,并且能实现线程安全,它的数组默认长度为16,相当于,对每一个数组元素上锁,允许16个线程并发执行,效率很快 -** 1.8版本**:使用了CAS算法+synchronized实现线程安全,如果CAS失败,就会使用synchronized

#### ArrayList和LinkedList的区别

##### ArrayList:

- **数据结构**:JDK源码是以Object数组,数据结构是数组形式存储,数组在内存中是一块连续的存储空间
- **线程安全**:线程不安全,源码没有使用同步关键字
- **效率**:查询效率快,通过索引,默认add方法,是把元素添加到数组的尾部,时间复杂度是O(1),需要扩容,需要扩容时,每次扩容原数组的1.5倍,
- **插入元素**：先copy原来的数组。copy的数组为从需要插入元素的下标index后面的数组进行copy，copy出来的数组向后移动一位，覆盖回去，这样就相当于挪出来了一个位置，然后再把数组中index的位置放入需要插入的元素就可以了；
- **删除元素**：数组需要删除元素的下标为index，会先把原来的数组从index+1copy一份，然后再放到index一开始的位置，做了一个覆盖的效果，看上去就像删了一样
- **内存空间占用**:添加元素需要扩容数组,数组默认长度为0,第一次添加,数组会把元素空间扩容到10,后面每次需要扩容预原数组的1.5倍,最好一开始就设定好大小，1.7默认调用this（10），使数组默认容量为10，1.8后默认长度为0

##### LinkedList:

- **数据结构**:JDK源码是以双向链表存储,链表的数据结构是在内存中是并不一定是连续的存储空间,1.6使用单向循环链表,存储一个指针指向下一个节点,最后一个节点指向第一个节点,形成链表循环,1.7以后是双向链表,双向链表指的是每个节点都存储了2个指针分别指向上一个节点和下一个节点,如果数据量很多,占用的内存空间大,
- **线程安全**:线程不安全,源码没有使用同步关键字
- **效率**:增加和删除效率快,直接删除节点,或者增加节点,不需要扩容,不受元素位置的影响
- **内存空间占用**:每个节点需要存储2个指针,去指向上一个和下一个节点,占用空间